pragma circom 2.1.9;

include "./components.circom";
include "./circomlib/comparators.circom";
include "./circomlib/bitify.circom";
include "./circomlib/poseidon.circom";

// Helper comparison templates
template GreaterEqThan(n) {
    assert(n <= 252);
    signal input in[2];
    signal output out;
    
    // in[0] >= in[1] is equivalent to in[1] <= in[0]
    component lt = LessThan(n);
    lt.in[0] <== in[1];
    lt.in[1] <== in[0] + 1;
    out <== lt.out;
}

template LessEqThan(n) {
    assert(n <= 252);
    signal input in[2];
    signal output out;
    
    // in[0] <= in[1] is equivalent to in[0] < in[1] + 1
    component lt = LessThan(n);
    lt.in[0] <== in[0];
    lt.in[1] <== in[1] + 1;
    out <== lt.out;
}

template IsEqual() {
    signal input in[2];
    signal output out;
    
    component isz = IsZero();
    isz.in <== in[1] - in[0];
    out <== isz.out;
}

template OR() {
    signal input a;
    signal input b;
    signal output out;
    
    out <== a + b - a*b;
}

template AND() {
    signal input a;
    signal input b;
    signal output out;
    
    out <== a*b;
}

// Action Circuit for WWIII Game - Validates Complete Mint Proofs with Server Authentication
// Takes ROCKET and SHIELD mint proof data as inputs, validates allocation constraints
// Only backend can generate valid proofs (server private key required)
template ActionCircuit() {
    ///////////////////////////////////////////////////
    ///                Private Inputs               ///
    ///////////////////////////////////////////////////
    
    // Server authentication (only backend knows this)
    signal input serverPrivateKey;   // Server private key for authentication
    
    // Player's allocation 
    signal input rocketAmount;       // Amount to allocate to ROCKET (attack)
    signal input shieldAmount;       // Amount to allocate to SHIELD (defense)
    
    // ROCKET mint proof data (pre-generated by backend)
    signal input rocketMintProof[8];              // ROCKET Groth16 proof points
    signal input rocketChainID;                   // Chain ID for ROCKET mint
    signal input rocketNullifierHash;             // Nullifier for ROCKET mint
    signal input rocketReceiverPublicKey[2];      // Target bunker's public key
    signal input rocketReceiverVTTC1[2];          // Encrypted amount c1
    signal input rocketReceiverVTTC2[2];          // Encrypted amount c2
    signal input rocketReceiverPCT[4];            // Receiver PCT (4 elements)
    signal input rocketReceiverPCTAuthKey[2];     // PCT auth key
    signal input rocketReceiverPCTNonce;          // PCT nonce
    signal input rocketAuditorPublicKey[2];       // Auditor public key
    signal input rocketAuditorPCT[4];             // Auditor PCT (4 elements)
    signal input rocketAuditorPCTAuthKey[2];      // Auditor PCT auth key
    signal input rocketAuditorPCTNonce;           // Auditor PCT nonce
    
    // SHIELD mint proof data (pre-generated by backend)
    signal input shieldMintProof[8];              // SHIELD Groth16 proof points
    signal input shieldChainID;                   // Chain ID for SHIELD mint
    signal input shieldNullifierHash;             // Nullifier for SHIELD mint
    signal input shieldReceiverPublicKey[2];      // Current bunker's public key
    signal input shieldReceiverVTTC1[2];          // Encrypted amount c1
    signal input shieldReceiverVTTC2[2];          // Encrypted amount c2
    signal input shieldReceiverPCT[4];            // Receiver PCT (4 elements)
    signal input shieldReceiverPCTAuthKey[2];     // PCT auth key
    signal input shieldReceiverPCTNonce;          // PCT nonce
    signal input shieldAuditorPublicKey[2];       // Auditor public key
    signal input shieldAuditorPCT[4];             // Auditor PCT (4 elements)
    signal input shieldAuditorPCTAuthKey[2];      // Auditor PCT auth key
    signal input shieldAuditorPCTNonce;           // Auditor PCT nonce
    
    ///////////////////////////////////////////////////
    ///                Public Inputs                ///
    ///////////////////////////////////////////////////
    
    // Bunker information
    signal input currentBunker;      // Player's current bunker ID (1-5)
    signal input targetBunkerId;     // Target bunker for ROCKET tokens (1-5)
    
    // Player and game state binding 
    signal input playerAddress;      // Player's Ethereum address 
    signal input currentRound;       // Current round number
    signal input deployedAmount;     // Total tokens player has deployed (validated on-chain)
    
    ///////////////////////////////////////////////////
    ///                Outputs                      ///
    ///////////////////////////////////////////////////
    
    // Server authentication output (verified by game contract)
    signal output serverPublicKeyHash; // Hash of server private key
    
    // Complete ROCKET mint proof data for game contract
    signal output rocketProofOut[8];
    signal output rocketPublicSignalsOut[24];
    
    // Complete SHIELD mint proof data for game contract  
    signal output shieldProofOut[8];
    signal output shieldPublicSignalsOut[24];
    
    ///////////////////////////////////////////////////
    ///           Server Authentication             ///
    ///////////////////////////////////////////////////
    
    // Compute hash of server private key and output it
    component serverKeyHasher = Poseidon(1);
    serverKeyHasher.inputs[0] <== serverPrivateKey;
    serverPublicKeyHash <== serverKeyHasher.out;
    
    ///////////////////////////////////////////////////
    ///             Constraint 1: Minimum Amounts   ///
    ///////////////////////////////////////////////////
    
    // Both ROCKET and SHIELD must be at least 1
    component checkMinRocket = GreaterEqThan(252);
    checkMinRocket.in[0] <== rocketAmount;
    checkMinRocket.in[1] <== 1;
    checkMinRocket.out === 1;
    
    component checkMinShield = GreaterEqThan(252);
    checkMinShield.in[0] <== shieldAmount;
    checkMinShield.in[1] <== 1;
    checkMinShield.out === 1;
    
    ///////////////////////////////////////////////////
    ///          Constraint 2: Total Allocation     ///
    ///////////////////////////////////////////////////
    
    // Total allocation cannot exceed deployment
    signal totalAmount <== rocketAmount + shieldAmount;
    
    component checkTotal = LessEqThan(252);
    checkTotal.in[0] <== totalAmount;
    checkTotal.in[1] <== deployedAmount;
    checkTotal.out === 1;
    
    ///////////////////////////////////////////////////
    ///          Constraint 3: Bunker Validation    ///
    ///////////////////////////////////////////////////
    
    // Target bunker must be valid (1-5)
    component checkTargetMin = GreaterEqThan(8);
    checkTargetMin.in[0] <== targetBunkerId;
    checkTargetMin.in[1] <== 1;
    checkTargetMin.out === 1;
    
    component checkTargetMax = LessEqThan(8);
    checkTargetMax.in[0] <== targetBunkerId;
    checkTargetMax.in[1] <== 5;
    checkTargetMax.out === 1;
    
    // Current bunker must be valid (1-5)
    component checkCurrentMin = GreaterEqThan(8);
    checkCurrentMin.in[0] <== currentBunker;
    checkCurrentMin.in[1] <== 1;
    checkCurrentMin.out === 1;
    
    component checkCurrentMax = LessEqThan(8);
    checkCurrentMax.in[0] <== currentBunker;
    checkCurrentMax.in[1] <== 5;
    checkCurrentMax.out === 1;
    
    // Cannot target own bunker (prevent self-attack)
    component checkNotSelf = IsEqual();
    checkNotSelf.in[0] <== targetBunkerId;
    checkNotSelf.in[1] <== currentBunker;
    checkNotSelf.out === 0; // Must be different
    
    ///////////////////////////////////////////////////
    ///        Constraint 4: Connection Validation  ///
    ///////////////////////////////////////////////////
    
    // Validate that currentBunker can attack targetBunkerId
    // Bunker 3 connects to all others (central hub)
    component isTargetBunker3 = IsEqual();
    isTargetBunker3.in[0] <== targetBunkerId;
    isTargetBunker3.in[1] <== 3;
    
    component isCurrentBunker3 = IsEqual();
    isCurrentBunker3.in[0] <== currentBunker;
    isCurrentBunker3.in[1] <== 3;
    
    // If either bunker is 3, connection is valid
    component bunker3Connection = OR();
    bunker3Connection.a <== isTargetBunker3.out;
    bunker3Connection.b <== isCurrentBunker3.out;
    
    // Specific connection rules for other bunkers
    // Bunker 1 ↔ 2, 4 (plus 3 handled above)
    component isCurrent1 = IsEqual();
    isCurrent1.in[0] <== currentBunker;
    isCurrent1.in[1] <== 1;
    
    component isTarget2or4FromBunker1 = OR();
    component isTarget2 = IsEqual();
    isTarget2.in[0] <== targetBunkerId;
    isTarget2.in[1] <== 2;
    component isTarget4 = IsEqual();
    isTarget4.in[0] <== targetBunkerId;
    isTarget4.in[1] <== 4;
    isTarget2or4FromBunker1.a <== isTarget2.out;
    isTarget2or4FromBunker1.b <== isTarget4.out;
    
    component bunker1Connection = AND();
    bunker1Connection.a <== isCurrent1.out;
    bunker1Connection.b <== isTarget2or4FromBunker1.out;
    
    // Bunker 2 ↔ 1, 5 (plus 3 handled above)
    component isCurrent2 = IsEqual();
    isCurrent2.in[0] <== currentBunker;
    isCurrent2.in[1] <== 2;
    
    component isTarget1or5FromBunker2 = OR();
    component isTarget1 = IsEqual();
    isTarget1.in[0] <== targetBunkerId;
    isTarget1.in[1] <== 1;
    component isTarget5 = IsEqual();
    isTarget5.in[0] <== targetBunkerId;
    isTarget5.in[1] <== 5;
    isTarget1or5FromBunker2.a <== isTarget1.out;
    isTarget1or5FromBunker2.b <== isTarget5.out;
    
    component bunker2Connection = AND();
    bunker2Connection.a <== isCurrent2.out;
    bunker2Connection.b <== isTarget1or5FromBunker2.out;
    
    // Bunker 4 ↔ 1, 5 (plus 3 handled above)
    component isCurrent4 = IsEqual();
    isCurrent4.in[0] <== currentBunker;
    isCurrent4.in[1] <== 4;
    
    component isTarget1or5FromBunker4 = OR();
    isTarget1or5FromBunker4.a <== isTarget1.out;
    isTarget1or5FromBunker4.b <== isTarget5.out;
    
    component bunker4Connection = AND();
    bunker4Connection.a <== isCurrent4.out;
    bunker4Connection.b <== isTarget1or5FromBunker4.out;
    
    // Bunker 5 ↔ 2, 4 (plus 3 handled above)
    component isCurrent5 = IsEqual();
    isCurrent5.in[0] <== currentBunker;
    isCurrent5.in[1] <== 5;
    
    component isTarget2or4FromBunker5 = OR();
    // Reuse isTarget2 and isTarget4 components from above
    isTarget2or4FromBunker5.a <== isTarget2.out;
    isTarget2or4FromBunker5.b <== isTarget4.out;
    
    component bunker5Connection = AND();
    bunker5Connection.a <== isCurrent5.out;
    bunker5Connection.b <== isTarget2or4FromBunker5.out;
    
    // Final connection validation: at least one connection rule must be satisfied
    component validConnection1 = OR();
    validConnection1.a <== bunker3Connection.out;
    validConnection1.b <== bunker1Connection.out;
    
    component validConnection2 = OR();
    validConnection2.a <== validConnection1.out;
    validConnection2.b <== bunker2Connection.out;
    
    component validConnection3 = OR();
    validConnection3.a <== validConnection2.out;
    validConnection3.b <== bunker4Connection.out;
    
    component finalConnectionCheck = OR();
    finalConnectionCheck.a <== validConnection3.out;
    finalConnectionCheck.b <== bunker5Connection.out;
    
    // Connection must be valid
    finalConnectionCheck.out === 1;
    
    ///////////////////////////////////////////////////
    ///              Mint Proof Outputs             ///
    ///////////////////////////////////////////////////
    
    // Output ROCKET mint proof points for game contract
    for (var i = 0; i < 8; i++) {
        rocketProofOut[i] <== rocketMintProof[i];
    }
    
    // Output ROCKET mint public signals in correct order (24 elements)
    rocketPublicSignalsOut[0] <== rocketChainID;
    rocketPublicSignalsOut[1] <== rocketNullifierHash;
    rocketPublicSignalsOut[2] <== rocketReceiverPublicKey[0];
    rocketPublicSignalsOut[3] <== rocketReceiverPublicKey[1];
    rocketPublicSignalsOut[4] <== rocketReceiverVTTC1[0];
    rocketPublicSignalsOut[5] <== rocketReceiverVTTC1[1];
    rocketPublicSignalsOut[6] <== rocketReceiverVTTC2[0];
    rocketPublicSignalsOut[7] <== rocketReceiverVTTC2[1];
    for (var i = 0; i < 4; i++) {
        rocketPublicSignalsOut[8 + i] <== rocketReceiverPCT[i];
    }
    rocketPublicSignalsOut[12] <== rocketReceiverPCTAuthKey[0];
    rocketPublicSignalsOut[13] <== rocketReceiverPCTAuthKey[1];
    rocketPublicSignalsOut[14] <== rocketReceiverPCTNonce;
    rocketPublicSignalsOut[15] <== rocketAuditorPublicKey[0];
    rocketPublicSignalsOut[16] <== rocketAuditorPublicKey[1];
    for (var i = 0; i < 4; i++) {
        rocketPublicSignalsOut[17 + i] <== rocketAuditorPCT[i];
    }
    rocketPublicSignalsOut[21] <== rocketAuditorPCTAuthKey[0];
    rocketPublicSignalsOut[22] <== rocketAuditorPCTAuthKey[1];
    rocketPublicSignalsOut[23] <== rocketAuditorPCTNonce;
    
    // Output SHIELD mint proof points for game contract
    for (var i = 0; i < 8; i++) {
        shieldProofOut[i] <== shieldMintProof[i];
    }
    
    // Output SHIELD mint public signals in correct order (24 elements)
    shieldPublicSignalsOut[0] <== shieldChainID;
    shieldPublicSignalsOut[1] <== shieldNullifierHash;
    shieldPublicSignalsOut[2] <== shieldReceiverPublicKey[0];
    shieldPublicSignalsOut[3] <== shieldReceiverPublicKey[1];
    shieldPublicSignalsOut[4] <== shieldReceiverVTTC1[0];
    shieldPublicSignalsOut[5] <== shieldReceiverVTTC1[1];
    shieldPublicSignalsOut[6] <== shieldReceiverVTTC2[0];
    shieldPublicSignalsOut[7] <== shieldReceiverVTTC2[1];
    for (var i = 0; i < 4; i++) {
        shieldPublicSignalsOut[8 + i] <== shieldReceiverPCT[i];
    }
    shieldPublicSignalsOut[12] <== shieldReceiverPCTAuthKey[0];
    shieldPublicSignalsOut[13] <== shieldReceiverPCTAuthKey[1];
    shieldPublicSignalsOut[14] <== shieldReceiverPCTNonce;
    shieldPublicSignalsOut[15] <== shieldAuditorPublicKey[0];
    shieldPublicSignalsOut[16] <== shieldAuditorPublicKey[1];
    for (var i = 0; i < 4; i++) {
        shieldPublicSignalsOut[17 + i] <== shieldAuditorPCT[i];
    }
    shieldPublicSignalsOut[21] <== shieldAuditorPCTAuthKey[0];
    shieldPublicSignalsOut[22] <== shieldAuditorPCTAuthKey[1];
    shieldPublicSignalsOut[23] <== shieldAuditorPCTNonce;
}

// Main component instantiation with public inputs and outputs
component main{public [currentBunker, targetBunkerId, playerAddress, currentRound, deployedAmount]} = ActionCircuit();