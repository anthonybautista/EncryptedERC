import { ethers, zkit } from "hardhat";
import { expect } from "chai";
import type { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import type { ActionCircuit } from "../../generated-types/zkit";
import type { ActionCircuitGroth16Verifier } from "../../generated-types";
import { poseidon } from "maci-crypto/build/ts/hashing";

describe("Action Circuit (Redesigned for Mint Proof Validation)", function () {
    let actionCircuit: ActionCircuit;
    let verifier: ActionCircuitGroth16Verifier;
    let accounts: SignerWithAddress[];
    
    // Mock server authentication data
    const serverPrivateKey = 12345678901234567890n;
    const serverPublicKeyHash = poseidon([serverPrivateKey]);
    
    // Mock complete mint proof data (matches eERC20 requirements)
    const mockRocketMintProof = [
        1234567890n, 2345678901n, 3456789012n, 4567890123n,
        5678901234n, 6789012345n, 7890123456n, 8901234567n
    ];
    
    const mockShieldMintProof = [
        9876543210n, 8765432109n, 7654321098n, 6543210987n,
        5432109876n, 4321098765n, 3210987654n, 2109876543n
    ];
    
    const sampleInputs = {
        // Private inputs - server authentication (prevents unauthorized proof generation)
        serverPrivateKey: serverPrivateKey,
        
        // Private inputs - allocation constraints (validated by circuit)
        rocketAmount: 400n, 
        shieldAmount: 600n,
        
        // Private inputs - ROCKET mint proof data (generated by backend)
        rocketMintProof: mockRocketMintProof,
        rocketChainID: 1n,
        rocketNullifierHash: 111111n,
        rocketReceiverPublicKey: [
            995203441582195749578291179787384436505546430278305826713579947235728471134n,
            5472060717959818805561601436314318772137091100104008585924551046643952123905n
        ],
        rocketReceiverVTTC1: [300n, 400n], // Encrypted amount c1
        rocketReceiverVTTC2: [500n, 600n], // Encrypted amount c2
        rocketReceiverPCT: [700n, 800n, 900n, 1000n], // 4-element PCT
        rocketReceiverPCTAuthKey: [1400n, 1500n],
        rocketReceiverPCTNonce: 1600n,
        rocketAuditorPublicKey: [1700n, 1800n],
        rocketAuditorPCT: [1900n, 2000n, 2100n, 2200n], // 4-element PCT
        rocketAuditorPCTAuthKey: [2600n, 2700n],
        rocketAuditorPCTNonce: 2800n,
        
        // Private inputs - SHIELD mint proof data (generated by backend)
        shieldMintProof: mockShieldMintProof,
        shieldChainID: 1n,
        shieldNullifierHash: 222222n,
        shieldReceiverPublicKey: [
            995203441582195749578291179787384436505546430278305826713579947235728471134n, 
            5472060717959818805561601436314318772137091100104008585924551046643952123905n
        ],
        shieldReceiverVTTC1: [3200n, 3300n], // Encrypted amount c1
        shieldReceiverVTTC2: [3400n, 3500n], // Encrypted amount c2
        shieldReceiverPCT: [3600n, 3700n, 3800n, 3900n], // 4-element PCT
        shieldReceiverPCTAuthKey: [4300n, 4400n],
        shieldReceiverPCTNonce: 4500n,
        shieldAuditorPublicKey: [4600n, 4700n],
        shieldAuditorPCT: [4800n, 4900n, 5000n, 5100n], // 4-element PCT
        shieldAuditorPCTAuthKey: [5500n, 5600n],
        shieldAuditorPCTNonce: 5700n,
        
        // Public inputs - bunker information (visible on-chain)
        currentBunker: 1n,
        targetBunkerId: 2n, // Target now visible (fog of war via encrypted amounts)
        
        // Public inputs - security binding (NEW)
        playerAddress: 123456789012345678901234567890123456789n, // Mock address as BigInt
        currentRound: 5n,
        deployedAmount: 1000n, // Moved from private inputs
    };

    before(async function () {
        accounts = await ethers.getSigners();
        
        // Initialize circuit for testing
        const circuit = await zkit.getCircuit("ActionCircuit");
        actionCircuit = circuit as unknown as ActionCircuit;
        
        // Deploy verifier contract
        const VerifierFactory = await ethers.getContractFactory("ActionCircuitGroth16Verifier");
        verifier = await VerifierFactory.deploy();
        await verifier.waitForDeployment();
    });

    describe("Server Authentication", function () {
        it("Should output correct server public key hash", async function () {
            // Test case: valid server key should produce correct hash
            const proof = await actionCircuit.generateProof(sampleInputs);
            expect(proof).to.exist;
            
            const calldata = await actionCircuit.generateCalldata(proof);
            
            // First public signal should be the server public key hash
            expect(BigInt(calldata.publicSignals[0])).to.equal(serverPublicKeyHash);
        });
        
        it("Should fail verification with wrong server private key", async function () {
            // Test case: unauthorized server key should produce different hash
            const invalidInputs = {
                ...sampleInputs,
                serverPrivateKey: 99999999999999999999n // Wrong key
            };
            
            // Circuit should still work but hash will be different
            const proof = await actionCircuit.generateProof(invalidInputs);
            const calldata = await actionCircuit.generateCalldata(proof);
            
            // Hash should be different from expected
            expect(BigInt(calldata.publicSignals[0])).to.not.equal(serverPublicKeyHash);
        });
    });

    describe("Allocation Constraint Validation", function () {
        it("Should enforce minimum 1 ROCKET token", async function () {
            // Test case: rocketAmount = 0 should fail
            const invalidInputs = {
                ...sampleInputs,
                rocketAmount: 0n,
                shieldAmount: 1000n // Total still equals deployedAmount
            };
            
            // This should fail constraint validation
            await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
        });

        it("Should enforce minimum 1 SHIELD token", async function () {
            // Test case: shieldAmount = 0 should fail
            const invalidInputs = {
                ...sampleInputs,
                rocketAmount: 1000n,
                shieldAmount: 0n // This should fail
            };
            
            // This should fail constraint validation
            await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
        });

        it("Should enforce total doesn't exceed deployment", async function () {
            // Test case: rocketAmount + shieldAmount > deployedAmount should fail
            const invalidInputs = {
                ...sampleInputs,
                deployedAmount: 1000n,
                rocketAmount: 600n,
                shieldAmount: 500n // Total = 1100 > 1000
            };
            
            // This should fail constraint validation
            await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
        });

        it("Should allow valid allocation within deployment", async function () {
            // Test case: valid allocation should pass
            const validInputs = {
                ...sampleInputs,
                deployedAmount: 1000n,
                rocketAmount: 400n,
                shieldAmount: 600n // Total = 1000 = deployedAmount
            };
            
            // This should pass constraint validation
            const proof = await actionCircuit.generateProof(validInputs);
            expect(proof).to.exist;
            
            // Verify the proof with circuit verification
            await expect(actionCircuit).to.verifyProof(proof);
            
            // Also verify with contract verifier using new 70-signal format
            const calldata = await actionCircuit.generateCalldata(proof);
            const pointA: [bigint, bigint] = [BigInt(calldata.proofPoints.a[0]), BigInt(calldata.proofPoints.a[1])];
            const pointB: [[bigint, bigint], [bigint, bigint]] = [[BigInt(calldata.proofPoints.b[0][0]), BigInt(calldata.proofPoints.b[0][1])], [BigInt(calldata.proofPoints.b[1][0]), BigInt(calldata.proofPoints.b[1][1])]];
            const pointC: [bigint, bigint] = [BigInt(calldata.proofPoints.c[0]), BigInt(calldata.proofPoints.c[1])];
            
            // Convert to 70-element array for new interface
            const signals: bigint[] = calldata.publicSignals.map(s => BigInt(s));
            expect(signals.length).to.equal(70);
            
            const isValid = await verifier.verifyProof(pointA, pointB, pointC, signals);
            expect(isValid).to.be.true;
        });

        it("Should allow allocation less than full deployment", async function () {
            // Test case: player doesn't have to use all deployed tokens
            const validInputs = {
                ...sampleInputs,
                deployedAmount: 1000n,
                rocketAmount: 300n,
                shieldAmount: 200n // Total = 500 < 1000 (valid)
            };
            
            // This should pass constraint validation
            const proof = await actionCircuit.generateProof(validInputs);
            expect(proof).to.exist;
            
            // Verify constraints in the proof
            expect(validInputs.rocketAmount).to.be.greaterThanOrEqual(1n);
            expect(validInputs.shieldAmount).to.be.greaterThanOrEqual(1n);
            expect(validInputs.rocketAmount + validInputs.shieldAmount).to.be.lessThanOrEqual(validInputs.deployedAmount);
        });
    });

    describe("Bunker Validation", function () {
        it("Should prevent self-targeting", async function () {
            // Test case: currentBunker = targetBunkerId should fail
            const invalidInputs = {
                ...sampleInputs,
                currentBunker: 3n,
                targetBunkerId: 3n // Same bunker - should fail
            };
            
            await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
        });

        it("Should validate bunker IDs in range [1-5]", async function () {
            // Test invalid current bunker
            const invalidCurrent = {
                ...sampleInputs,
                currentBunker: 0n, // Invalid - outside range
                targetBunkerId: 2n
            };
            
            await expect(actionCircuit.generateProof(invalidCurrent)).to.be.rejected;
            
            // Test invalid target bunker
            const invalidTarget = {
                ...sampleInputs,
                currentBunker: 1n,
                targetBunkerId: 6n // Invalid - outside range
            };
            
            await expect(actionCircuit.generateProof(invalidTarget)).to.be.rejected;
        });
    });

    describe("Connection Topology Validation", function () {
        it("Should allow valid connections from bunker 1", async function () {
            // Test case: Bunker 1 connects to 2, 3, 4 (not 5)
            const validTargets = [2n, 3n, 4n];
            
            for (const target of validTargets) {
                const inputs = {
                    ...sampleInputs,
                    currentBunker: 1n,
                    targetBunkerId: target
                };
                
                const proof = await actionCircuit.generateProof(inputs);
                expect(proof).to.exist;
            }
        });

        it("Should reject invalid connections from bunker 1", async function () {
            // Test case: Bunker 1 cannot connect to 5
            const invalidInputs = {
                ...sampleInputs,
                currentBunker: 1n,
                targetBunkerId: 5n // Invalid connection
            };
            
            await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
        });

        it("Should allow valid connections from bunker 3 (central hub)", async function () {
            // Test case: Bunker 3 connects to all others (1, 2, 4, 5)
            const validTargets = [1n, 2n, 4n, 5n];
            
            for (const target of validTargets) {
                const inputs = {
                    ...sampleInputs,
                    currentBunker: 3n,
                    targetBunkerId: target
                };
                
                const proof = await actionCircuit.generateProof(inputs);
                expect(proof).to.exist;
            }
        });

        it("Should validate bunker connection topology rules", async function () {
            // Test connection matrix:
            // Bunker 1 ↔ 2, 3, 4 (not 5)
            // Bunker 2 ↔ 1, 3, 5 (not 4)  
            // Bunker 3 ↔ 1, 2, 4, 5 (central hub)
            // Bunker 4 ↔ 1, 3, 5 (not 2)
            // Bunker 5 ↔ 2, 3, 4 (not 1)
            
            const connectionMatrix = {
                1: [2, 3, 4],      // Bunker 1 valid targets
                2: [1, 3, 5],      // Bunker 2 valid targets
                3: [1, 2, 4, 5],   // Bunker 3 valid targets (central hub)
                4: [1, 3, 5],      // Bunker 4 valid targets
                5: [2, 3, 4]       // Bunker 5 valid targets
            };
            
            // Test valid connections
            for (const [current, validTargets] of Object.entries(connectionMatrix)) {
                for (const target of validTargets) {
                    const inputs = {
                        ...sampleInputs,
                        currentBunker: BigInt(current),
                        targetBunkerId: BigInt(target)
                    };
                    
                    const proof = await actionCircuit.generateProof(inputs);
                    expect(proof).to.exist;
                }
            }
        });

        it("Should reject invalid bunker IDs", async function () {
            // Test invalid bunker IDs
            const invalidIds = [0, 6, 7, 10, 100];
            
            for (const id of invalidIds) {
                expect(id < 1 || id > 5).to.be.true;
            }
        });

        it("Should prevent self-targeting", async function () {
            // Test case: targeting own bunker should fail
            const invalidInputs = {
                ...sampleInputs,
                currentBunker: 3n,
                targetBunkerId: 3n // Same as current bunker
            };
            
            // This should fail circuit constraint validation
            await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
        });
    });

    describe("Bunker Connection Validation", function () {
        it("Should allow attacks from bunker 3 to any other bunker", async function () {
            // Bunker 3 is the central hub - can attack all others
            const validTargets = [1n, 2n, 4n, 5n];
            
            for (const target of validTargets) {
                const validInputs = {
                    ...sampleInputs,
                    currentBunker: 3n,
                    targetBunkerId: target
                };
                
                // Should pass connection validation
                const proof = await actionCircuit.generateProof(validInputs);
                expect(proof).to.exist;
            }
        });

        it("Should allow attacks to bunker 3 from any other bunker", async function () {
            // Any bunker can attack the central hub (bunker 3)
            const validSources = [1n, 2n, 4n, 5n];
            
            for (const source of validSources) {
                const validInputs = {
                    ...sampleInputs,
                    currentBunker: source,
                    targetBunkerId: 3n
                };
                
                // Should pass connection validation
                const proof = await actionCircuit.generateProof(validInputs);
                expect(proof).to.exist;
            }
        });

        it("Should allow valid non-hub connections", async function () {
            // Test specific valid connections
            const validConnections = [
                { from: 1n, to: 2n }, // Bunker 1 ↔ 2
                { from: 1n, to: 4n }, // Bunker 1 ↔ 4
                { from: 2n, to: 1n }, // Bunker 2 ↔ 1
                { from: 2n, to: 5n }, // Bunker 2 ↔ 5
                { from: 4n, to: 1n }, // Bunker 4 ↔ 1
                { from: 4n, to: 5n }, // Bunker 4 ↔ 5
                { from: 5n, to: 2n }, // Bunker 5 ↔ 2
                { from: 5n, to: 4n }, // Bunker 5 ↔ 4
            ];
            
            for (const connection of validConnections) {
                const validInputs = {
                    ...sampleInputs,
                    currentBunker: connection.from,
                    targetBunkerId: connection.to
                };
                
                // Should pass connection validation
                const proof = await actionCircuit.generateProof(validInputs);
                expect(proof).to.exist;
            }
        });

        it("Should reject invalid connections", async function () {
            // Test specific invalid connections
            const invalidConnections = [
                { from: 1n, to: 5n }, // Bunker 1 cannot reach 5 directly
                { from: 5n, to: 1n }, // Bunker 5 cannot reach 1 directly
                { from: 2n, to: 4n }, // Bunker 2 cannot reach 4 directly
                { from: 4n, to: 2n }, // Bunker 4 cannot reach 2 directly
            ];
            
            for (const connection of invalidConnections) {
                const invalidInputs = {
                    ...sampleInputs,
                    currentBunker: connection.from,
                    targetBunkerId: connection.to
                };
                
                // Should fail connection validation
                await expect(actionCircuit.generateProof(invalidInputs)).to.be.rejected;
            }
        });
    });

    describe("Encryption Output", function () {
        it("Should generate encrypted values for minting", async function () {
            // The circuit should output encrypted amounts for ROCKET and SHIELD
            // Format: [c1.x, c1.y, c2.x, c2.y] for each token
            
            const expectedOutputs = {
                rocketEncrypted: [4], // Array of 4 elements (c1.x, c1.y, c2.x, c2.y)
                shieldEncrypted: [4], // Array of 4 elements  
                targetAddress: 1      // Single field for target bunker
            };
            
            // Verify output structure
            expect(expectedOutputs.rocketEncrypted).to.have.lengthOf(1);
            expect(expectedOutputs.shieldEncrypted).to.have.lengthOf(1);
            expect(typeof expectedOutputs.targetAddress).to.equal("number");
        });

        it("Should use different public keys for encryption", async function () {
            // ROCKET should be encrypted to target bunker's key
            // SHIELD should be encrypted to player's current bunker key
            
            const targetBunkerKey = ["123", "456"];
            const playerBunkerKey = ["789", "012"];
            
            // These should be different unless player is defending themselves
            // (which may be valid in some cases)
            expect(targetBunkerKey).to.not.deep.equal(playerBunkerKey);
        });
    });

    describe("Nonce and Replay Prevention", function () {
        it("Should use unique nonces for different actions", async function () {
            const action1 = { ...sampleInputs, actionNonce: "123" };
            const action2 = { ...sampleInputs, actionNonce: "456" };
            
            expect(action1.actionNonce).to.not.equal(action2.actionNonce);
        });

        it("Should handle large nonce values", async function () {
            const largeNonce = "999999999999999";
            const inputs = { ...sampleInputs, actionNonce: largeNonce };
            
            expect(inputs.actionNonce).to.equal(largeNonce);
        });
    });

    describe("Edge Cases", function () {
        it("Should handle minimum valid allocation", async function () {
            const minInputs = {
                ...sampleInputs,
                deployedAmount: "2",
                rocketAmount: "1",
                shieldAmount: "1"
            };
            
            const total = parseInt(minInputs.rocketAmount) + parseInt(minInputs.shieldAmount);
            expect(total).to.equal(parseInt(minInputs.deployedAmount));
        });

        it("Should handle large deployment amounts", async function () {
            const largeInputs = {
                ...sampleInputs,
                deployedAmount: 1000000000n, // 1 billion
                rocketAmount: 400000000n,
                shieldAmount: 600000000n
            };
            
            // This should pass constraint validation with 252-bit support
            const proof = await actionCircuit.generateProof(largeInputs);
            expect(proof).to.exist;
            
            // Verify with both circuit and contract
            await expect(actionCircuit).to.verifyProof(proof);
            const calldata = await actionCircuit.generateCalldata(proof);
            const pointA: [bigint, bigint] = [BigInt(calldata.proofPoints.a[0]), BigInt(calldata.proofPoints.a[1])];
            const pointB: [[bigint, bigint], [bigint, bigint]] = [[BigInt(calldata.proofPoints.b[0][0]), BigInt(calldata.proofPoints.b[0][1])], [BigInt(calldata.proofPoints.b[1][0]), BigInt(calldata.proofPoints.b[1][1])]];
            const pointC: [bigint, bigint] = [BigInt(calldata.proofPoints.c[0]), BigInt(calldata.proofPoints.c[1])];
            
            // Convert to 70-element array for new interface
            const signals: bigint[] = calldata.publicSignals.map(s => BigInt(s));
            expect(signals.length).to.equal(70);
            
            const isValid = await verifier.verifyProof(pointA, pointB, pointC, signals);
            expect(isValid).to.be.true;
        });

        it("Should handle real ether amounts (10K+ tokens)", async function () {
            const tenKEther = ethers.parseEther("10000");
            const fiveKEther = ethers.parseEther("5000");
            
            const etherInputs = {
                ...sampleInputs,
                deployedAmount: tenKEther,
                rocketAmount: fiveKEther,
                shieldAmount: fiveKEther
            };
            
            // This should pass constraint validation with 252-bit support
            const proof = await actionCircuit.generateProof(etherInputs);
            expect(proof).to.exist;
            
            // Verify with both circuit and contract
            await expect(actionCircuit).to.verifyProof(proof);
            const calldata = await actionCircuit.generateCalldata(proof);
            const pointA: [bigint, bigint] = [BigInt(calldata.proofPoints.a[0]), BigInt(calldata.proofPoints.a[1])];
            const pointB: [[bigint, bigint], [bigint, bigint]] = [[BigInt(calldata.proofPoints.b[0][0]), BigInt(calldata.proofPoints.b[0][1])], [BigInt(calldata.proofPoints.b[1][0]), BigInt(calldata.proofPoints.b[1][1])]];
            const pointC: [bigint, bigint] = [BigInt(calldata.proofPoints.c[0]), BigInt(calldata.proofPoints.c[1])];
            
            // Convert to 70-element array for new interface
            const signals: bigint[] = calldata.publicSignals.map(s => BigInt(s));
            expect(signals.length).to.equal(70);
            
            const isValid = await verifier.verifyProof(pointA, pointB, pointC, signals);
            expect(isValid).to.be.true;
        });

        it("Should handle very large amounts (100M+ tokens)", async function () {
            const hundredMillion = ethers.parseEther("100000000"); // 100 million tokens
            const fiftyMillion = ethers.parseEther("50000000");
            
            const massiveInputs = {
                ...sampleInputs,
                deployedAmount: hundredMillion,
                rocketAmount: fiftyMillion,
                shieldAmount: fiftyMillion
            };
            
            // This should pass constraint validation with 252-bit support
            const proof = await actionCircuit.generateProof(massiveInputs);
            expect(proof).to.exist;
            
            // Verify with both circuit and contract
            await expect(actionCircuit).to.verifyProof(proof);
            const calldata = await actionCircuit.generateCalldata(proof);
            const pointA: [bigint, bigint] = [BigInt(calldata.proofPoints.a[0]), BigInt(calldata.proofPoints.a[1])];
            const pointB: [[bigint, bigint], [bigint, bigint]] = [[BigInt(calldata.proofPoints.b[0][0]), BigInt(calldata.proofPoints.b[0][1])], [BigInt(calldata.proofPoints.b[1][0]), BigInt(calldata.proofPoints.b[1][1])]];
            const pointC: [bigint, bigint] = [BigInt(calldata.proofPoints.c[0]), BigInt(calldata.proofPoints.c[1])];
            
            // Convert to 70-element array for new interface
            const signals: bigint[] = calldata.publicSignals.map(s => BigInt(s));
            expect(signals.length).to.equal(70);
            
            const isValid = await verifier.verifyProof(pointA, pointB, pointC, signals);
            expect(isValid).to.be.true;
        });

        it("Should handle maximum field element values", async function () {
            // Circom field elements have a maximum value
            const maxField = "21888242871839275222246405745257275088548364400416034343698204186575808495617";
            
            // Deployment amounts should be well below this limit
            expect(BigInt("1000000000")).to.be.lessThan(BigInt(maxField));
        });
    });

    describe("Gas Estimation", function () {
        it("Should estimate proof generation time", async function () {
            // This will be measured once the circuit is implemented
            const startTime = Date.now();
            
            // Simulate proof generation work
            await new Promise(resolve => setTimeout(resolve, 10));
            
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            console.log(`Simulated proof generation time: ${duration}ms`);
            expect(duration).to.be.greaterThan(0);
        });

        it("Should estimate proof verification gas cost", async function () {
            // Target: < 800k gas as specified in BUILD_PLAN
            const targetGasLimit = 800000;
            
            // This will be measured with actual verifier contract
            console.log(`Target gas limit: ${targetGasLimit}`);
            expect(targetGasLimit).to.be.greaterThan(0);
        });
    });

    describe("Mint Proof Passthrough Validation", function () {
        it("Should output complete ROCKET mint proof data", async function () {
            // Test case: verify ROCKET mint proof is correctly passed through
            const proof = await actionCircuit.generateProof(sampleInputs);
            const calldata = await actionCircuit.generateCalldata(proof);
            
            // Check ROCKET proof points (indices 1-8)
            for (let i = 0; i < 8; i++) {
                expect(BigInt(calldata.publicSignals[1 + i])).to.equal(mockRocketMintProof[i]);
            }
            
            // Check ROCKET public signals start (indices 9-12) 
            expect(BigInt(calldata.publicSignals[9])).to.equal(1n); // chainID
            expect(BigInt(calldata.publicSignals[10])).to.equal(111111n); // nullifierHash
            expect(BigInt(calldata.publicSignals[11])).to.equal(sampleInputs.rocketReceiverPublicKey[0]); // receiverPublicKey[0]
            expect(BigInt(calldata.publicSignals[12])).to.equal(sampleInputs.rocketReceiverPublicKey[1]); // receiverPublicKey[1]
        });

        it("Should output complete SHIELD mint proof data", async function () {
            // Test case: verify SHIELD mint proof is correctly passed through
            const proof = await actionCircuit.generateProof(sampleInputs);
            const calldata = await actionCircuit.generateCalldata(proof);
            
            // Check SHIELD proof points (indices 33-40)
            for (let i = 0; i < 8; i++) {
                expect(BigInt(calldata.publicSignals[33 + i])).to.equal(mockShieldMintProof[i]);
            }
            
            // Check SHIELD public signals start (indices 41-44)
            expect(BigInt(calldata.publicSignals[41])).to.equal(1n); // chainID
            expect(BigInt(calldata.publicSignals[42])).to.equal(222222n); // nullifierHash
            expect(BigInt(calldata.publicSignals[43])).to.equal(sampleInputs.shieldReceiverPublicKey[0]); // receiverPublicKey[0]
            expect(BigInt(calldata.publicSignals[44])).to.equal(sampleInputs.shieldReceiverPublicKey[1]); // receiverPublicKey[1]
        });

        it("Should output bunker information at correct indices", async function () {
            // Test case: verify bunker data is at expected positions
            const proof = await actionCircuit.generateProof(sampleInputs);
            const calldata = await actionCircuit.generateCalldata(proof);
            
            // Check current bunker (index 65)
            expect(BigInt(calldata.publicSignals[65])).to.equal(1n);
            
            // Check target bunker (index 66) 
            expect(BigInt(calldata.publicSignals[66])).to.equal(2n);
            
            // Check player address (index 67)
            expect(BigInt(calldata.publicSignals[67])).to.equal(123456789012345678901234567890123456789n);
            
            // Check current round (index 68)
            expect(BigInt(calldata.publicSignals[68])).to.equal(5n);
            
            // Check deployed amount (index 69)
            expect(BigInt(calldata.publicSignals[69])).to.equal(1000n);
            
            // Verify total public signal count is 70
            expect(calldata.publicSignals.length).to.equal(70);
        });

        it("Should maintain mint proof integrity for eERC20 compatibility", async function () {
            // Test case: verify mint proofs contain all required eERC20 data
            const proof = await actionCircuit.generateProof(sampleInputs);
            const calldata = await actionCircuit.generateCalldata(proof);
            
            // ROCKET mint proof validation (24 public signals)
            const rocketSignals = calldata.publicSignals.slice(9, 33); // indices 9-32
            expect(rocketSignals.length).to.equal(24);
            
            // Verify key components are present
            expect(BigInt(rocketSignals[0])).to.equal(1n); // chainID
            expect(BigInt(rocketSignals[1])).to.equal(111111n); // nullifierHash
            expect(BigInt(rocketSignals[2])).to.equal(sampleInputs.rocketReceiverPublicKey[0]); // receiverPublicKey[0]
            expect(BigInt(rocketSignals[3])).to.equal(sampleInputs.rocketReceiverPublicKey[1]); // receiverPublicKey[1]
            
            // SHIELD mint proof validation (24 public signals)
            const shieldSignals = calldata.publicSignals.slice(41, 65); // indices 41-64
            expect(shieldSignals.length).to.equal(24);
            
            // Verify key components are present
            expect(BigInt(shieldSignals[0])).to.equal(1n); // chainID
            expect(BigInt(shieldSignals[1])).to.equal(222222n); // nullifierHash
            expect(BigInt(shieldSignals[2])).to.equal(sampleInputs.shieldReceiverPublicKey[0]); // receiverPublicKey[0]
            expect(BigInt(shieldSignals[3])).to.equal(sampleInputs.shieldReceiverPublicKey[1]); // receiverPublicKey[1]
        });
    });
});